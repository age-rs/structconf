use crate::error::{Error, ErrorKind, Result};

use darling::FromField;
use syn::{spanned::Spanned, Field, Ident, Type};

/// The basic structure for the field's data, containing all the available
/// attributes in `#[conf(...)]` and some additional data. This is first
/// obtained with the module `darling`, and then parsed into a higher level
/// structure defined later.
///
/// It remains private to the main module because it's meant to be an
/// intermediate step to ease parsing.
#[derive(FromField)]
#[darling(attributes(conf))]
struct BasicOptAttrs {
    ident: Option<Ident>,
    ty: Type,
    #[darling(skip)]
    is_option: bool,
    #[darling(default)]
    default: Option<String>,
    #[darling(default)]
    no_long: bool,
    #[darling(default)]
    long: Option<String>,
    #[darling(default)]
    no_short: bool,
    #[darling(default)]
    short: Option<String>,
    #[darling(default)]
    help: Option<String>,
    #[darling(default)]
    inverse_arg: bool,
    #[darling(default)]
    no_file: bool,
    #[darling(default)]
    file: Option<String>,
    #[darling(default)]
    section: Option<String>,
}

impl BasicOptAttrs {
    /// Method to initialize a `BasicOptAttrs` completely, from the parsing
    /// done by `darling`, and some extra checks for conflicts and for the
    /// type. The `BasicOptAttrs::from_field` method generated by `darling`
    /// shouldn't be used by itself.
    pub fn init(field: Field) -> Result<BasicOptAttrs> {
        let opt_attrs = BasicOptAttrs::from_field(&field)?;
        opt_attrs.check_conflicts()?;
        let (ty, is_option) = opt_attrs.get_type();

        Ok(BasicOptAttrs {
            ty,
            is_option,
            ..opt_attrs
        })
    }

    fn check_conflicts(&self) -> Result<()> {
        // Given an original expression and a list of other expressions it
        // conflicts with, it returns an error in case both of them are true.
        // The macro makes this a bit less repetitive.
        macro_rules! check_conflicts {
            ($orig:expr, $others:expr) => {
                let (orig, orig_name) = $orig;
                if orig {
                    for (confl, confl_name) in $others.iter() {
                        if *confl {
                            return Err(Error {
                                span: self.ident.span(),
                                kind: ErrorKind::Conflict(
                                    orig_name.to_string(),
                                    confl_name.to_string()
                                )
                            });
                        }
                    }
                }
            };
        }

        // Empty fields may not use any other attribute
        check_conflicts!(
            (
                self.no_short && self.no_long && self.no_file,
                "no_short, no_long and no_file"
            ),
            [
                (self.default.is_some(), "default"),
                (self.long.is_some(), "long"),
                (self.short.is_some(), "short"),
                (self.help.is_some(), "help"),
                (self.inverse_arg, "inverse_arg"),
                (self.file.is_some(), "file"),
                (self.section.is_some(), "section"),
            ]
        );

        check_conflicts!(
            (self.no_short, "no_short"),
            [(self.short.is_some(), "short"),]
        );

        check_conflicts!(
            (self.no_long, "no_long"),
            [(self.long.is_some(), "long"),]
        );

        check_conflicts!(
            (self.no_short && self.no_long, "no_short and no_long"),
            [
                (self.inverse_arg, "inverse_arg"),
                (self.help.is_some(), "help"),
            ]
        );

        check_conflicts!(
            (self.no_file, "no_file"),
            [
                (self.file.is_some(), "file"),
                (self.section.is_some(), "section"),
            ]
        );

        Ok(())
    }

    /// Returns the type of the option or the inner type in an `Option<T>`,
    /// and whether it was optional or not.
    fn get_type(&self) -> (Type, bool) {
        // Painfully obtaining the type `T` inside `Option<T>` for parsing.
        use syn::{TypePath, Path};

        // Checking the type is wrapped by an `Option<T>`.
        // eprintln!("TYPE: {:#?}", &self.ty);
        if let Type::Path(TypePath { path: Path { segments, .. }, .. }) = &self.ty {
            if segments.len() == 1 && segments.first().unwrap().ident == "Option" {
                let args = &segments.first().unwrap().arguments;
                use syn::{
                    PathArguments::AngleBracketed as PathAngles,
                    AngleBracketedGenericArguments as Brackets,
                    GenericArgument::Type as InnerType,
                };

                // Obtaining the type inside the `Option<T>`.
                if let PathAngles(Brackets { args, .. }) = args {
                    if let InnerType(ty) = args.first().unwrap() {
                        // eprintln!("IT'S OPTIONAAAAAAL");
                        return (ty.clone(), true)
                    }
                }
            }
        }

        (self.ty.clone(), false)
    }

    pub fn parse_file(&self) -> Option<OptFileData> {
        if self.no_file {
            None
        } else {
            Some(OptFileData {
                section: self
                    .section
                    .clone()
                    .unwrap_or(String::from("Defaults")),
            })
        }
    }

    pub fn parse_arg(&self) -> Result<Option<OptArgData>> {
        // The long or short values may be empty, meaning that the
        // value should be converted from the field name.
        if self.no_long && self.no_short {
            Ok(None)
        } else {
            let get_ident = || self.ident.clone().unwrap().to_string();

            let long: Option<String> = if self.no_long {
                None
            } else {
                Some(self.long.to_owned().unwrap_or_else(get_ident))
            };

            let short = if self.no_short {
                None
            } else {
                match self.short.to_owned() {
                    Some(s) => {
                        // If the user provides the short name, this makes
                        // sure it's a single character.
                        let mut chars = s.chars();
                        let first = chars.next();
                        let second = chars.next();

                        match (first, second) {
                            (Some(ch), None) => Some(ch.to_string()),
                            _ => {
                                return Err(Error {
                                    span: self.ident.span(),
                                    kind: ErrorKind::Parse(
                                        String::from("short argument can't \
                                        be longer than one character")
                                    )
                                })
                            }
                        }
                    }
                    None => {
                        // Otherwise, the short name is obtained from the
                        // identifier, which must be at least a character
                        // long, so `unwrap()` is used.
                        Some(get_ident().chars().nth(0).unwrap().to_string())
                    }
                }
            };

            Ok(Some(OptArgData {
                long,
                short,
                help: self.help.clone(),
                inverse: self.inverse_arg,
            }))
        }
    }
}

/// The higher level structure with already processed data for an option.
pub struct Opt {
    pub name: Ident,
    pub ty: Type,
    pub is_option: bool,
    pub default: Option<String>,
    pub file: Option<OptFileData>,
    pub arg: Option<OptArgData>,
}

pub struct OptArgData {
    pub long: Option<String>,
    pub short: Option<String>,
    pub help: Option<String>,
    pub inverse: bool,
}

pub struct OptFileData {
    pub section: String,
}

impl Opt {
    pub fn parse(field: Field) -> Result<Opt> {
        let opt_attrs = BasicOptAttrs::init(field)?;

        Ok(Opt {
            file: opt_attrs.parse_file(),
            arg: opt_attrs.parse_arg()?,
            is_option: opt_attrs.is_option,
            default: opt_attrs.default,
            name: opt_attrs.ident.unwrap(),
            ty: opt_attrs.ty,
        })
    }
}

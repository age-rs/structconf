use crate::error::{Error, ErrorKind, Result};

use darling::FromField;
use quote::quote;
use proc_macro2::TokenStream as TokenStream2;
use syn::{spanned::Spanned, Field, Ident, Type, Expr};

/// The basic structure for the field's data, containing all the available
/// attributes in `#[conf(...)]` and some additional data. This is first
/// obtained with the module `darling`, and then parsed into a higher level
/// structure defined later.
///
/// It remains private to the main module because it's meant to be an
/// intermediate step to ease parsing.
#[derive(FromField)]
#[darling(attributes(conf))]
struct BasicOptAttrs {
    ident: Option<Ident>,
    ty: Type,
    #[darling(skip)]
    is_option: bool,
    #[darling(default)]
    default: Option<String>,
    #[darling(default)]
    no_long: bool,
    #[darling(default)]
    long: Option<String>,
    #[darling(default)]
    no_short: bool,
    #[darling(default)]
    short: Option<String>,
    #[darling(default)]
    help: Option<String>,
    #[darling(default)]
    inverse_arg: bool,
    #[darling(default)]
    no_file: bool,
    #[darling(default)]
    file: Option<String>,
    #[darling(default)]
    section: Option<String>,
}

impl BasicOptAttrs {
    /// Method to initialize a `BasicOptAttrs` completely, from the parsing
    /// done by `darling`, and some extra checks for conflicts and for the
    /// type. The `BasicOptAttrs::from_field` method generated by `darling`
    /// shouldn't be used by itself.
    pub fn init(field: Field) -> Result<BasicOptAttrs> {
        let opt_attrs = BasicOptAttrs::from_field(&field)?;
        opt_attrs.check_conflicts()?;
        let (ty, is_option) = opt_attrs.get_type();

        Ok(BasicOptAttrs {
            ty,
            is_option,
            ..opt_attrs
        })
    }

    fn check_conflicts(&self) -> Result<()> {
        // Given an original expression and a list of other expressions it
        // conflicts with, it returns an error in case both of them are true.
        // The macro makes this a bit less repetitive.
        macro_rules! check_conflicts {
            ($orig:expr, $others:expr) => {
                let (orig, orig_name) = $orig;
                if orig {
                    for (confl, confl_name) in $others.iter() {
                        if *confl {
                            return Err(Error {
                                span: self.ident.span(),
                                kind: ErrorKind::Conflict(
                                    orig_name.to_string(),
                                    confl_name.to_string(),
                                ),
                            });
                        }
                    }
                }
            };
        }

        // Empty fields may not use any other attribute
        check_conflicts!(
            (
                self.no_short && self.no_long && self.no_file,
                "no_short, no_long and no_file"
            ),
            [
                (self.default.is_some(), "default"),
                (self.long.is_some(), "long"),
                (self.short.is_some(), "short"),
                (self.help.is_some(), "help"),
                (self.inverse_arg, "inverse_arg"),
                (self.file.is_some(), "file"),
                (self.section.is_some(), "section"),
            ]
        );

        check_conflicts!(
            (self.no_short, "no_short"),
            [(self.short.is_some(), "short"),]
        );

        check_conflicts!(
            (self.no_long, "no_long"),
            [(self.long.is_some(), "long"),]
        );

        check_conflicts!(
            (self.no_short && self.no_long, "no_short and no_long"),
            [
                (self.inverse_arg, "inverse_arg"),
                (self.help.is_some(), "help"),
            ]
        );

        check_conflicts!(
            (self.no_file, "no_file"),
            [
                (self.file.is_some(), "file"),
                (self.section.is_some(), "section"),
            ]
        );

        Ok(())
    }

    /// Returns the type of the option or the inner type in an `Option<T>`,
    /// and whether it was optional or not.
    fn get_type(&self) -> (Type, bool) {
        // Painfully obtaining the type `T` inside `Option<T>` for parsing.
        use syn::{Path, TypePath};

        // Checking the type is wrapped by an `Option<T>`.
        if let Type::Path(TypePath {
            path: Path { segments, .. },
            ..
        }) = &self.ty
        {
            if segments.len() == 1
                && segments.first().unwrap().ident == "Option"
            {
                let args = &segments.first().unwrap().arguments;
                use syn::{
                    AngleBracketedGenericArguments as Brackets,
                    GenericArgument::Type as InnerType,
                    PathArguments::AngleBracketed as PathAngles,
                };

                // Obtaining the type inside the `Option<T>`.
                if let PathAngles(Brackets { args, .. }) = args {
                    if let InnerType(ty) = args.first().unwrap() {
                        return (ty.clone(), true);
                    }
                }
            }
        }

        (self.ty.clone(), false)
    }

    pub fn parse_file(&self) -> Option<OptFileData> {
        if self.no_file {
            None
        } else {
            Some(OptFileData {
                section: self
                    .section
                    .clone()
                    .unwrap_or(String::from("Defaults")),
            })
        }
    }

    pub fn parse_arg(&self) -> Result<Option<OptArgData>> {
        // The long or short values may be empty, meaning that the
        // value should be converted from the field name.
        if self.no_long && self.no_short {
            Ok(None)
        } else {
            let get_ident = || self.ident.clone().unwrap().to_string();

            let long: Option<String> = if self.no_long {
                None
            } else {
                Some(self.long.to_owned().unwrap_or_else(get_ident))
            };

            let short = if self.no_short {
                None
            } else {
                match self.short.to_owned() {
                    Some(s) => {
                        // If the user provides the short name, this makes
                        // sure it's a single character.
                        let mut chars = s.chars();
                        let first = chars.next();
                        let second = chars.next();

                        match (first, second) {
                            (Some(ch), None) => Some(ch.to_string()),
                            _ => {
                                return Err(Error {
                                    span: self.ident.span(),
                                    kind: ErrorKind::Parse(String::from(
                                        "short argument can't \
                                        be longer than one character",
                                    )),
                                })
                            }
                        }
                    }
                    None => {
                        // Otherwise, the short name is obtained from the
                        // identifier, which must be at least a character
                        // long, so `unwrap()` is used.
                        Some(get_ident().chars().nth(0).unwrap().to_string())
                    }
                }
            };

            Ok(Some(OptArgData {
                long,
                short,
                help: self.help.clone(),
                inverse: self.inverse_arg,
            }))
        }
    }
}

/// The higher level structure with already processed data for an option.
pub struct Opt {
    pub name: Ident,
    pub ty: Type,
    pub is_option: bool,
    pub default: Option<String>,
    pub file: Option<OptFileData>,
    pub arg: Option<OptArgData>,
}

pub struct OptArgData {
    pub long: Option<String>,
    pub short: Option<String>,
    pub help: Option<String>,
    pub inverse: bool,
}

pub struct OptFileData {
    pub section: String,
}

impl Opt {
    pub fn parse(field: Field) -> Result<Opt> {
        let opt_attrs = BasicOptAttrs::init(field)?;

        Ok(Opt {
            file: opt_attrs.parse_file(),
            arg: opt_attrs.parse_arg()?,
            is_option: opt_attrs.is_option,
            default: opt_attrs.default,
            name: opt_attrs.ident.unwrap(),
            ty: opt_attrs.ty,
        })
    }

    /// This will return a tokenstream for each field that has to be
    /// initialized, depending on whether the option is an argument, a
    /// config file option, none, or both:
    ///
    /// ```rust
    /// field: {
    ///     // May go through no branches, branch A, branch B, or both
    ///     // branches.
    ///     let mut opt: Option<String> = None;
    ///
    ///     // Branch A (argument)
    ///     opt = arg.value_of(...);
    ///
    ///     // Branch B (config file)
    ///     if let None = opt {
    ///         opt = file.get_from(...);
    ///     }
    ///
    ///     match opt {
    ///         // Branch A, B, or both
    ///         Some(opt) => {
    ///             // Parse `opt`
    ///             let opt = opt.parse()?;
    ///         
    ///             // Branch A, if `inverse_arg`, after parsing.
    ///             // `inverse_arg` // may only be true if it's an argument.
    ///             if arg.value_of(...).is_some() {
    ///                 opt = !opt;
    ///             }
    ///         },
    ///         // None
    ///         None => default
    ///     }
    /// }
    /// ```
    ///
    /// This is intended to be as flexible as possible, and to avoid
    /// repetition in the code, so it may not be optimized for some cases. For
    /// example, if the option is neither a config file option nor an
    /// argument, the `match` block is useless because it's obvious it's going
    /// to go through the `None` branch. But these cases are easy to optimize
    /// by the compiler, so it's not important.
    ///
    /// Methods like `unwrap_or` can't be used here because this has to be
    /// able to propagate errors with `?`.
    pub fn into_field_init(&self) -> Result<TokenStream2> {
        let Opt { name, ty, is_option, arg, ..  } = self;

        // Obtains a TokenStream with what the default value of the option
        // is going to be. If `default` was used, the expression is used.
        // Otherwise, the type's default value is used, which may be `None`
        // in case the type is an `Option<T>`.
        let default = match self.default.to_owned() {
            Some(expr) => {
                let expr = syn::parse_str::<Expr>(&expr)?;
                if *is_option {
                    quote! { Some(#expr) }
                } else {
                    quote! { #expr }
                }
            }
            None => {
                if *is_option {
                    quote! { None }
                } else {
                    quote! { ::std::default::Default::default() }
                }
            }
        };

        let val_ret = if *is_option {
            quote! { Some(opt) }
        } else {
            quote! { opt }
        };

        let mut value = quote! {
            let mut opt: Option<&str> = None;
        };

        let mut invert_opt = TokenStream2::new();
        if let Some(OptArgData { inverse, .. }) = arg {
            value.extend(quote! {
                opt = args.value_of(stringify!(#name));
            });

            if *inverse {
                invert_opt.extend(quote! {
                    if args.value_of(stringify!(#name)).is_some() {
                        opt = !opt;
                    }
                });
            }
        }

        if let Some(OptFileData { section, .. }) = &self.file {
            value.extend(quote! {
                if let None = opt {
                    opt = file.get_from(Some(#section), stringify!(#name));
                }
            });
        }

        value.extend(quote! {
            match opt {
                Some(opt) => {
                    let mut opt = opt
                        .parse::<#ty>()
                        .map_err(|e| {
                            ::structconf::Error::Parse(e.to_string())
                        })?;
                    #invert_opt
                    #val_ret
                },
                None => #default
            }
        });

        Ok(quote! {
            #name: { #value }
        })
    }

    pub fn into_arg_init(&self) -> Option<TokenStream2> {
        // In case it's not an argument, an empty TokenStream will be
        // returned.
        if let Some(data) = &self.arg {
            let name = self.name.to_string();
            let mut init = quote! {
                ::clap::Arg::with_name(#name)
            };

            if let Some(help) = &data.help {
                init.extend(quote! {
                    .help(#help)
                });
            }

            if let Some(long) = &data.long {
                init.extend(quote! {
                    .long(#long)
                });
            }

            if let Some(short) = &data.short {
                init.extend(quote! {
                    .short(#short)
                });
            }

            Some(init)
        } else {
            None
        }
    }

    pub fn into_to_file(&self) -> Option<TokenStream2> {
        self.file.as_ref().and_then(|file| {
            let name = self.name.clone();
            let section = file.section.as_str();

            Some(if self.is_option {
                quote! {
                    if let Some(val) = &self.#name {
                        conf.with_section(Some(#section))
                            .set(stringify!(#name), val.to_string());
                    }
                }
            } else {
                quote! {
                    conf.with_section(Some(#section))
                        .set(stringify!(#name), self.#name.to_string());
                }
            })
        })
    }
}
